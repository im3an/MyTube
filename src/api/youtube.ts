/**
 * YouTube data via Piped API — no API key, no account required.
 * Uses public Piped instances that extract YouTube data via NewPipeExtractor.
 * When VITE_USE_BACKEND=1, delegates to backend API (cache + DB + Piped).
 * @see https://docs.piped.video/docs/api-documentation/
 */

import { getSearchLangForRegion, type RegionCode } from '@/data/regions'
import { pipedFetch } from './pipedClient'
import { resolveChannelIdentity } from '@/services/channelService'
import * as backend from './backend'

const USE_BACKEND = import.meta.env.VITE_USE_BACKEND === '1' || import.meta.env.VITE_USE_BACKEND === 'true'

// ─── Piped raw response types (internal) ─────────────────────

interface PipedStreamItem {
  url: string
  type?: string
  title: string
  thumbnail: string
  uploaderName: string
  uploaderUrl: string
  uploaderAvatar: string
  uploadedDate: string
  shortDescription?: string | null
  duration: number
  views: number
  uploaded: number
  uploaderVerified: boolean
  isShort?: boolean
  livestream?: boolean
}

interface PipedStreamDetail {
  title: string
  description: string
  uploadDate: string
  uploader: string
  uploaderUrl: string
  uploaderAvatar: string
  uploaderVerified: boolean
  uploaderSubscriberCount?: number
  thumbnailUrl: string
  hls: string | null
  dash: string | null
  category: string
  livestream: boolean
  duration: number
  views: number
  likes: number
  dislikes: number
  audioStreams: PipedMediaStream[]
  videoStreams: PipedMediaStream[]
  relatedStreams: PipedStreamItem[]
  subtitles?: { url: string; mimeType?: string; name?: string; code?: string; autoGenerated?: boolean }[]
}

interface PipedMediaStream {
  url: string
  format: string
  quality: string
  mimeType: string
  codec?: string
  videoOnly: boolean
  bitrate: number
  width?: number
  height?: number
  fps?: number
}

interface PipedCommentItem {
  author: string
  commentId: string
  commentText: string
  commentedTime: string
  commentorUrl: string
  hearted: boolean
  likeCount: number
  pinned: boolean
  thumbnail: string
  verified: boolean
  creatorReplied: boolean
}

interface PipedChannelItem {
  url: string
  type: 'channel'
  name: string
  thumbnail: string
  description?: string | null
  subscribers: number
  videos: number
  verified: boolean
}

// ─── Exported types (kept compatible with existing consumers) ─

export interface SearchChannel {
  id: string
  name: string
  avatarUrl: string
  description?: string
  subscriberCount: number
  videoCount: number
  verified: boolean
}

export interface InvidiousVideo {
  type?: string
  title: string
  videoId: string
  author: string
  authorId: string
  authorUrl: string
  videoThumbnails: { quality: string; url: string; width: number; height: number }[]
  viewCount: number
  viewCountText?: string
  published: number
  publishedText: string
  lengthSeconds: number
  description?: string
  descriptionHtml?: string
  liveNow?: boolean
  paid?: boolean
  premium?: boolean
  authorThumbnails?: { url: string; width: number; height: number }[]
  authorVerified?: boolean
}

export interface SubtitleTrack {
  url: string
  mimeType: string
  name: string
  code: string
  autoGenerated: boolean
}

export interface InvidiousVideoDetail extends InvidiousVideo {
  description: string
  descriptionHtml: string
  dashUrl?: string
  hlsUrl?: string
  adaptiveFormats: { url: string; qualityLabel?: string; type: string; container: string }[]
  formatStreams: { url: string; quality: string; qualityLabel: string }[]
  recommendedVideos: InvidiousVideo[]
  likeCount: number
  dislikeCount: number
  subscriberCount?: number
  subtitles?: SubtitleTrack[]
}

export interface InvidiousComment {
  commentId?: string
  author: string
  authorThumbnails: { url: string }[]
  content: string
  publishedText: string
  likeCount: number
}

export interface ChannelInfo {
  id: string
  name: string
  avatarUrl: string
  bannerUrl: string
  description: string
  subscriberCount: number
  verified: boolean
  videos: InvidiousVideo[]
  nextpage: string | null
}

// ─── Mappers (Piped → app types) ────────────────────────────

function extractVideoId(url: string): string {
  const match = url?.match(/[?&]v=([^&]+)/)
  return match?.[1] ?? ''
}

function extractChannelId(url: string): string {
  if (!url) return ''
  // Handle /channel/UCxxx or https://...youtube.com/channel/UCxxx
  const channelMatch = url.match(/\/channel\/([^/?]+)/)
  if (channelMatch) return channelMatch[1]
  // Handle /@handle
  const handleMatch = url.match(/\/@([^/?]+)/)
  if (handleMatch) return `@${handleMatch[1]}`
  return url.replace(/^\/channel\//, '')
}

function pipedItemToVideo(s: PipedStreamItem): InvidiousVideo {
  const isLive = s.livestream ?? (s.duration <= 0 || s.duration === -1)
  return {
    type: 'video',
    title: s.title,
    videoId: extractVideoId(s.url),
    author: s.uploaderName,
    authorId: extractChannelId(s.uploaderUrl),
    authorUrl: s.uploaderUrl,
    videoThumbnails: [{ quality: 'medium', url: s.thumbnail, width: 320, height: 180 }],
    viewCount: s.views ?? 0,
    published: s.uploaded ? Math.floor(s.uploaded / 1000) : 0,
    publishedText: s.uploadedDate ?? '',
    lengthSeconds: s.duration,
    liveNow: isLive,
    description: s.shortDescription ?? undefined,
    authorThumbnails: s.uploaderAvatar
      ? [{ url: s.uploaderAvatar, width: 48, height: 48 }]
      : undefined,
    authorVerified: s.uploaderVerified ?? false,
  }
}

function pipedDetailToVideoDetail(
  videoId: string,
  d: PipedStreamDetail,
): InvidiousVideoDetail {
  // Non-video-only streams can play directly (contain both audio + video)
  const formatStreams = d.videoStreams
    .filter((s) => !s.videoOnly)
    .map((s) => ({
      url: s.url,
      quality: s.quality,
      qualityLabel: s.quality,
    }))

  // Video-only + audio-only streams for adaptive playback
  const adaptiveFormats = [
    ...d.audioStreams.map((s) => ({
      url: s.url,
      qualityLabel: s.quality,
      type: s.mimeType,
      container: s.format,
    })),
    ...d.videoStreams
      .filter((s) => s.videoOnly)
      .map((s) => ({
        url: s.url,
        qualityLabel: s.quality,
        type: s.mimeType,
        container: s.format,
      })),
  ]

  return {
    type: 'video',
    title: d.title,
    videoId,
    author: d.uploader,
    authorId: extractChannelId(d.uploaderUrl),
    authorUrl: d.uploaderUrl,
    videoThumbnails: [{ quality: 'medium', url: d.thumbnailUrl, width: 320, height: 180 }],
    viewCount: d.views ?? 0,
    published: 0,
    publishedText: d.uploadDate ?? '',
    lengthSeconds: d.duration,
    liveNow: d.livestream,
    authorThumbnails: d.uploaderAvatar
      ? [{ url: d.uploaderAvatar, width: 48, height: 48 }]
      : undefined,
    authorVerified: d.uploaderVerified ?? false,
    description: d.description,
    descriptionHtml: d.description,
    dashUrl: d.dash ?? undefined,
    hlsUrl: d.hls ?? undefined,
    adaptiveFormats,
    formatStreams,
    recommendedVideos: (d.relatedStreams ?? [])
      .filter((s) => s.url?.includes('/watch'))
      .map(pipedItemToVideo),
    likeCount: d.likes ?? 0,
    dislikeCount: d.dislikes ?? 0,
    subscriberCount: d.uploaderSubscriberCount,
    subtitles: (d.subtitles ?? []).map((s) => ({
      url: s.url,
      mimeType: s.mimeType ?? 'text/vtt',
      name: s.name ?? '',
      code: s.code ?? 'en',
      autoGenerated: s.autoGenerated ?? false,
    })),
  }
}

function pipedCommentToComment(c: PipedCommentItem): InvidiousComment {
  return {
    commentId: c.commentId,
    author: c.author,
    authorThumbnails: c.thumbnail ? [{ url: c.thumbnail }] : [],
    content: c.commentText,
    publishedText: c.commentedTime,
    likeCount: c.likeCount ?? 0,
  }
}

/** Map YouTube oEmbed response → InvidiousVideoDetail (minimal but enough to render cards) */
function oembedToVideoDetail(
  videoId: string,
  data: { title?: string; author_name?: string; author_url?: string; thumbnail_url?: string },
): InvidiousVideoDetail {
  const channelHandle = data.author_url?.split('/').pop() ?? ''
  return {
    type: 'video',
    title: data.title ?? 'Untitled',
    videoId,
    author: data.author_name ?? 'Unknown',
    authorId: channelHandle,
    authorUrl: data.author_url ?? '',
    videoThumbnails: [{
      quality: 'medium',
      url: data.thumbnail_url ?? `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
      width: 480,
      height: 360,
    }],
    viewCount: 0,
    published: 0,
    publishedText: '',
    lengthSeconds: 0,
    description: '',
    descriptionHtml: '',
    adaptiveFormats: [],
    formatStreams: [],
    recommendedVideos: [],
    likeCount: 0,
    dislikeCount: 0,
  }
}

// ─── API functions ──────────────────────────────────────────

export async function searchVideos(q: string): Promise<InvidiousVideo[]> {
  const { videos } = await searchVideosPage(q)
  return videos
}

/** Paginated search — returns videos + an opaque nextpage token for infinite scroll. */
/** When region is set, appends a language keyword to bias results (e.g. FR → "français"). */
export async function searchVideosPage(
  q: string,
  nextpage?: string,
  region?: string,
): Promise<{ videos: InvidiousVideo[]; nextpage: string | null }> {
  const lang = region ? getSearchLangForRegion(region as RegionCode) : ''
  const searchQ = lang ? `${q} ${lang}`.trim() : q
  if (USE_BACKEND) {
    const result = await backend.searchVideosPage(searchQ, nextpage, region)
    return { videos: result.videos as InvidiousVideo[], nextpage: result.nextpage }
  }
  const path = nextpage
    ? `/nextpage/search?q=${encodeURIComponent(searchQ)}&filter=videos&nextpage=${encodeURIComponent(nextpage)}`
    : `/search?q=${encodeURIComponent(searchQ)}&filter=videos`
  const res = await pipedFetch(path)
  if (!res.ok) throw new Error('Search failed')
  const data = await res.json()
  const items: PipedStreamItem[] = data?.items ?? data ?? []
  return {
    videos: (Array.isArray(items) ? items : [])
      .filter((i) => i.url?.includes('/watch'))
      .map(pipedItemToVideo),
    nextpage: data?.nextpage ?? null,
  }
}

/** Search for channels — returns channel profiles matching the query. */
export async function searchChannels(
  q: string,
  region?: string,
): Promise<SearchChannel[]> {
  const lang = region ? getSearchLangForRegion(region as RegionCode) : ''
  const searchQ = lang ? `${q} ${lang}`.trim() : q
  const res = await pipedFetch(
    `/search?q=${encodeURIComponent(searchQ)}&filter=channels`,
  )
  if (!res.ok) return []
  const data = await res.json()
  const items: PipedChannelItem[] = data?.items ?? data ?? []
  return (Array.isArray(items) ? items : [])
    .filter((i) => i.type === 'channel' && i.url?.includes('/channel/'))
    .map((c) => ({
      id: extractChannelId(c.url),
      name: c.name ?? '',
      avatarUrl: c.thumbnail ?? '',
      description: c.description ?? undefined,
      subscriberCount: c.subscribers >= 0 ? c.subscribers : 0,
      videoCount: c.videos >= 0 ? c.videos : 0,
      verified: c.verified ?? false,
    }))
}

/** Autocomplete suggestions from Piped. */
export async function getSearchSuggestions(q: string): Promise<string[]> {
  try {
    const res = await pipedFetch(
      `/suggestions?query=${encodeURIComponent(q)}`,
    )
    if (!res.ok) return []
    const data = await res.json()
    return Array.isArray(data) ? data : []
  } catch {
    return []
  }
}

export async function getTrending(region = 'US'): Promise<InvidiousVideo[]> {
  if (USE_BACKEND) {
    const data = await backend.getTrending(region)
    return data as InvidiousVideo[]
  }
  const res = await pipedFetch(`/trending?region=${region}`)
  if (!res.ok) throw new Error('Trending failed')
  const data = await res.json()
  return (Array.isArray(data) ? data : []).map(pipedItemToVideo)
}

// Circuit breaker: skip Piped /streams/ after consecutive failures, re-check periodically
let _pipedStreamsDown = false
let _pipedStreamsLastCheck = 0
const PIPED_RETRY_MS = 5 * 60 * 1000 // retry every 5 min

/**
 * SAFE: Metadata only (title, thumbnail, author). Uses YouTube oEmbed — never hits Piped /streams.
 * Use for: Homepage lists, History, Playlist, Favorites, Watch Later, Command menu, etc.
 */
export async function getVideoMeta(
  videoId: string,
): Promise<InvidiousVideoDetail | null> {
  try {
    const res = await fetch(`/api/oembed/${videoId}`)
    if (res.ok) {
      const oembed = await res.json()
      return oembedToVideoDetail(videoId, oembed)
    }
  } catch {
    /* ignore */
  }
  return null
}

/** Public Piped instance for fallback when backend fails (500, timeout, etc.) */
const PIPED_FALLBACK_BASE = 'https://pipedapi.kavin.rocks'

/**
 * DANGEROUS: Full detail + playback streams. Hits Piped /streams/ — rate-limited, heavy.
 * Use ONLY on the Video Watch Page, never in lists or staggered loops.
 */
export async function getVideoStreams(
  videoId: string,
): Promise<InvidiousVideoDetail | null> {
  if (USE_BACKEND) {
    const fromBackend = await backend.getVideo(videoId)
    if (fromBackend) return fromBackend as InvidiousVideoDetail
    // Fallback: backend returned null (500/timeout) — try public Piped directly
    try {
      const res = await fetch(`${PIPED_FALLBACK_BASE}/streams/${videoId}`, {
        headers: { Accept: 'application/json' },
        signal: AbortSignal.timeout(15_000),
      })
      if (res.ok) {
        const data = (await res.json()) as PipedStreamDetail
        if (!('error' in (data as unknown as Record<string, unknown>))) {
          return pipedDetailToVideoDetail(videoId, data)
        }
      }
    } catch { /* fallback failed */ }
    return null
  }
  const now = Date.now()
  const shouldTryPiped = !_pipedStreamsDown || now - _pipedStreamsLastCheck > PIPED_RETRY_MS

  // Try Piped streams (full detail + playback URLs) unless circuit is open
  if (shouldTryPiped) {
    try {
      const res = await pipedFetch(`/streams/${videoId}`)
      _pipedStreamsLastCheck = now
      if (res.ok) {
        const data: PipedStreamDetail = await res.json()
        if (!('error' in (data as unknown as Record<string, unknown>))) {
          _pipedStreamsDown = false
          return pipedDetailToVideoDetail(videoId, data)
        }
      }
      // 500 / error in body → mark as down
      _pipedStreamsDown = true
    } catch {
      _pipedStreamsDown = true
    }
  }

  // Fallback: YouTube oEmbed (always works, gives title + thumbnail + author)
  try {
    const res = await fetch(`/api/oembed/${videoId}`)
    if (res.ok) {
      const oembed = await res.json()
      const detail = oembedToVideoDetail(videoId, oembed)

      // Enrich with related videos by searching the video title (Piped search works)
      try {
        const query = oembed.title || oembed.author_name || videoId
        const searchRes = await pipedFetch(
          `/search?q=${encodeURIComponent(query)}&filter=videos`,
        )
        if (searchRes.ok) {
          const searchData = await searchRes.json()
          const items: PipedStreamItem[] = searchData?.items ?? []
          detail.recommendedVideos = items
            .filter((i) => i.url?.includes('/watch') && extractVideoId(i.url) !== videoId)
            .slice(0, 12)
            .map(pipedItemToVideo)
        }
      } catch { /* no related videos, that's ok */ }

      return detail
    }
  } catch { /* give up */ }

  return null
}

/** @deprecated Use getVideoMeta for lists, getVideoStreams for watch page. Kept for compatibility. */
export const getVideo = getVideoStreams

export async function getComments(
  videoId: string,
): Promise<InvidiousComment[]> {
  const { comments } = await getCommentsPage(videoId)
  return comments
}

/** Paginated comments — returns comments + nextpage token for "load more". */
export async function getCommentsPage(
  videoId: string,
  nextpage?: string,
): Promise<{ comments: InvidiousComment[]; nextpage: string | null; disabled: boolean }> {
  try {
    const path = nextpage
      ? `/nextpage/comments/${videoId}?nextpage=${encodeURIComponent(nextpage)}`
      : `/comments/${videoId}`
    const res = await pipedFetch(path)
    if (!res.ok) return { comments: [], nextpage: null, disabled: false }
    const data = await res.json()
    return {
      comments: (data?.comments ?? []).map(pipedCommentToComment),
      nextpage: data?.nextpage ?? null,
      disabled: data?.disabled ?? false,
    }
  } catch {
    return { comments: [], nextpage: null, disabled: false }
  }
}

// ─── Channel API ─────────────────────────────────────────────

export { isCanonicalChannelId } from '@/services/channelService'

/** Global channel cache — keyed by both handle and UC ID. */
const channelCache = new Map<string, Promise<ChannelInfo | null>>()

function parseChannelResponse(
  d: Record<string, unknown>,
  channelId: string
): ChannelInfo {
  const videos: InvidiousVideo[] = ((d.relatedStreams as PipedStreamItem[]) ?? [])
    .filter((s) => s.url?.includes('/watch'))
    .map(pipedItemToVideo)
  return {
    id: (d.id as string) ?? channelId,
    name: (d.name as string) ?? '',
    avatarUrl: (d.avatarUrl as string) ?? '',
    bannerUrl: (d.bannerUrl as string) ?? '',
    description: (d.description as string) ?? '',
    subscriberCount: (d.subscriberCount as number) ?? 0,
    verified: (d.verified as boolean) ?? false,
    videos,
    nextpage: (d.nextpage as string) ?? null,
  }
}

/**
 * Fetch channel by canonical UC ID only. Never use /channel/@handle or /user/ directly.
 */
async function fetchChannelByUcId(ucId: string): Promise<ChannelInfo | null> {
  const res = await pipedFetch(`/channel/${encodeURIComponent(ucId)}`)
  if (!res.ok) return null
  const d = (await res.json()) as Record<string, unknown>
  if (!d || 'error' in d) return null
  return parseChannelResponse(d, ucId)
}

export async function getChannel(channelId: string): Promise<ChannelInfo | null> {
  if (USE_BACKEND) {
    return backend.getChannel(channelId) as Promise<ChannelInfo | null>
  }

  const cacheKey = channelId.trim()
  const cached = channelCache.get(cacheKey)
  if (cached) return cached

  const promise = (async (): Promise<ChannelInfo | null> => {
    try {
      const identity = await resolveChannelIdentity(channelId)
      if (!identity?.id) return null

      const result = await fetchChannelByUcId(identity.id)
      if (result) {
        channelCache.set(identity.id, Promise.resolve(result))
      }
      return result
    } catch {
      return null
    }
  })()

  channelCache.set(cacheKey, promise)
  return promise
}

export async function getChannelNextPage(
  channelId: string,
  nextpage: string,
): Promise<{ videos: InvidiousVideo[]; nextpage: string | null }> {
  try {
    const identity = await resolveChannelIdentity(channelId)
    const ucId = identity?.id
    if (!ucId) return { videos: [], nextpage: null }

    const res = await pipedFetch(
      `/nextpage/channel/${encodeURIComponent(ucId)}?nextpage=${encodeURIComponent(nextpage)}`,
    )
    if (!res.ok) return { videos: [], nextpage: null }
    const d = await res.json()
    const videos: InvidiousVideo[] = (d.relatedStreams ?? [])
      .filter((s: PipedStreamItem) => s.url?.includes('/watch'))
      .map(pipedItemToVideo)
    return { videos, nextpage: d.nextpage ?? null }
  } catch {
    return { videos: [], nextpage: null }
  }
}

// ─── Formatting helpers ─────────────────────────────────────

/** High-quality thumbnail for hero/featured (1280×720). Falls back to hqdefault if maxres doesn't exist. */
export function getHighQualityThumbnail(videoId: string): string {
  return `https://i.ytimg.com/vi/${videoId}/maxresdefault.jpg`
}

export function getFallbackThumbnail(videoId: string): string {
  return `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`
}

export function formatDuration(seconds: number): string {
  const h = Math.floor(seconds / 3600)
  const m = Math.floor((seconds % 3600) / 60)
  const s = Math.floor(seconds % 60)
  if (h > 0)
    return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`
  return `${m}:${s.toString().padStart(2, '0')}`
}

export function formatViews(count: number): string {
  if (count >= 1e9) return (count / 1e9).toFixed(1) + 'B'
  if (count >= 1e6) return (count / 1e6).toFixed(1) + 'M'
  if (count >= 1e3) return (count / 1e3).toFixed(1) + 'K'
  return String(count)
}

export function toAppVideo(v: InvidiousVideo): {
  id: string
  title: string
  channelName: string
  channelId: string
  channelAvatar: string
  channelVerified: boolean
  views: string
  uploadedAt: string
  thumbnail: string
  category: string
  duration?: string
  liveNow?: boolean
  viewCount: number
  lengthSeconds: number
  published: number
} {
  return {
    id: v.videoId,
    title: v.title,
    channelName: v.author,
    channelId: v.authorId,
    channelAvatar:
      v.authorThumbnails?.[0]?.url ?? '',
    channelVerified: v.authorVerified ?? false,
    views: v.viewCountText ?? (v.viewCount ? formatViews(v.viewCount) : ''),
    uploadedAt: v.publishedText ?? '',
    thumbnail:
      v.videoThumbnails?.[0]?.url ||
      `https://img.youtube.com/vi/${v.videoId}/hqdefault.jpg`,
    category: 'all',
    duration: v.lengthSeconds > 0 ? formatDuration(v.lengthSeconds) : undefined,
    liveNow: v.liveNow,
    viewCount: v.viewCount ?? 0,
    lengthSeconds: v.lengthSeconds ?? 0,
    published: v.published ?? 0,
  }
}
