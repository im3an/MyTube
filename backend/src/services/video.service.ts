/**
 * Video business logic: cache -> DB -> Piped. Returns DTOs for API.
 */

import * as videoQueries from '../db/queries/videos.js'
import * as channelQueries from '../db/queries/channels.js'
import { getCachedVideo, setCachedVideo, invalidateVideo } from '../cache/memory.js'
import { getStreams } from './piped.service.js'
import { toVideoDetailDto, toVideoListItem, type VideoDetailDto, type VideoListItem } from '../utils/dto.js'
import { NotFoundError } from '../utils/errors.js'

function extractChannelId(url: string): string {
  if (!url) return ''
  const channelMatch = url.match(/\/channel\/([^/?]+)/)
  if (channelMatch) return channelMatch[1]
  const handleMatch = url.match(/\/@([^/?]+)/)
  if (handleMatch) return `@${handleMatch[1]}`
  return url.replace(/^\/channel\//, '')
}

function extractVideoId(url: string): string {
  const m = url?.match(/[?&]v=([^&]+)/)
  return m?.[1] ?? ''
}

/** Map Piped stream response to our stored raw_json shape (so toVideoDetailDto works). */
function normalizePipedStream(videoId: string, d: Record<string, unknown>): Record<string, unknown> {
  const videoStreams = (d.videoStreams as Array<{ url: string; quality: string; videoOnly?: boolean; mimeType?: string; format?: string }>) ?? []
  const audioStreams = (d.audioStreams as Array<{ url: string; quality: string; mimeType?: string; format?: string }>) ?? []
  const formatStreams = videoStreams
    .filter((s) => !s.videoOnly)
    .map((s) => ({ url: s.url, quality: s.quality, qualityLabel: s.quality }))
  const adaptiveFormats = [
    ...audioStreams.map((s) => ({ url: s.url, qualityLabel: s.quality, type: s.mimeType ?? '', container: s.format ?? '' })),
    ...videoStreams.filter((s) => s.videoOnly).map((s) => ({ url: s.url, qualityLabel: s.quality, type: s.mimeType ?? '', container: s.format ?? '' })),
  ]
  const relatedStreams = (d.relatedStreams as Array<Record<string, unknown>>) ?? []
  const recommendedVideos = relatedStreams
    .filter((s) => String(s.url ?? '').includes('/watch'))
    .map((s) => {
      const id = extractVideoId(String(s.url ?? ''))
      return {
        videoId: id,
        id,
        title: s.title,
        author: s.uploaderName,
        authorId: extractChannelId(String(s.uploaderUrl ?? '')),
        authorUrl: s.uploaderUrl,
        videoThumbnails: [{ quality: 'medium', url: s.thumbnail, width: 320, height: 180 }],
        viewCount: s.views ?? 0,
        published: 0,
        publishedText: s.uploadedDate ?? '',
        lengthSeconds: s.duration ?? 0,
        authorThumbnails: s.uploaderAvatar ? [{ quality: 'default', url: s.uploaderAvatar, width: 48, height: 48 }] : undefined,
        authorVerified: s.uploaderVerified ?? false,
      }
    })
  const subtitles = (d.subtitles as Array<{ url: string; mimeType?: string; name?: string; code?: string; autoGenerated?: boolean }>)?.map((s) => ({
    url: s.url,
    mimeType: s.mimeType ?? 'text/vtt',
    name: s.name ?? '',
    code: s.code ?? 'en',
    autoGenerated: s.autoGenerated ?? false,
  }))
  return {
    ...d,
    formatStreams,
    adaptiveFormats,
    recommendedVideos,
    likeCount: d.likes ?? 0,
    dislikeCount: d.dislikes ?? 0,
    subtitles: subtitles ?? [],
  }
}

/** Get video by ID: L1 cache -> DB -> Piped. */
export async function getVideoById(id: string): Promise<VideoDetailDto> {
  const cached = getCachedVideo<VideoDetailDto>(id)
  if (cached) return cached

  let row: Awaited<ReturnType<typeof videoQueries.getVideoById>> = null
  try {
    row = await videoQueries.getVideoById(id)
  } catch {
    /* DB unreachable; fall through to Piped */
  }
  if (row) {
    const dto = toVideoDetailDto(row as unknown as Record<string, unknown>)
    setCachedVideo(id, dto)
    return dto
  }

  const piped = await getStreams(id)
  if (!piped || (piped as Record<string, unknown>).error) {
    throw new NotFoundError('Video not found')
  }

  const d = piped as Record<string, unknown>
  const channelId = extractChannelId(String(d.uploaderUrl ?? ''))
  const rawJson = normalizePipedStream(id, d)

  try {
    await channelQueries.upsertChannel({
      id: channelId,
      name: String(d.uploader ?? ''),
      avatar_url: String(d.uploaderAvatar ?? ''),
      banner_url: undefined,
      subscriber_count: Number(d.uploaderSubscriberCount ?? 0),
      verified: Boolean(d.uploaderVerified),
      raw_json: null,
    })
    await videoQueries.upsertVideo({
      id,
      channel_id: channelId,
      title: String(d.title ?? ''),
      description: String(d.description ?? ''),
      thumbnail_url: String(d.thumbnailUrl ?? ''),
      duration_sec: Number(d.duration ?? 0),
      published_at: null,
      raw_json: rawJson,
    })
  } catch {
    /* DB write failed; still return the DTO */
  }

  const dto = toVideoDetailDto({
    id,
    channel_id: channelId,
    title: d.title,
    description: d.description,
    thumbnail_url: d.thumbnailUrl,
    duration_sec: d.duration,
    published_at: null,
    raw_json: rawJson,
  } as unknown as Record<string, unknown>)
  setCachedVideo(id, dto)
  return dto
}
