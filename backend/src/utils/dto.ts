/**
 * Response transformers. Minimal payloads; no raw_json in list responses.
 * Shapes match frontend InvidiousVideo / InvidiousVideoDetail / ChannelInfo.
 */

export interface VideoThumbnail {
  quality: string
  url: string
  width: number
  height: number
}

export interface VideoListItem {
  type?: 'video'
  title: string
  videoId: string
  author: string
  authorId: string
  authorUrl: string
  videoThumbnails: VideoThumbnail[]
  viewCount: number
  viewCountText?: string
  published: number
  publishedText: string
  lengthSeconds: number
  description?: string
  liveNow?: boolean
  authorThumbnails?: VideoThumbnail[]
  authorVerified?: boolean
}

export interface VideoDetailDto extends VideoListItem {
  description: string
  descriptionHtml: string
  dashUrl?: string
  hlsUrl?: string
  adaptiveFormats: { url: string; qualityLabel?: string; type: string; container: string }[]
  formatStreams: { url: string; quality: string; qualityLabel: string }[]
  recommendedVideos: VideoListItem[]
  likeCount: number
  dislikeCount: number
  subscriberCount?: number
  subtitles?: { url: string; mimeType: string; name: string; code: string; autoGenerated: boolean }[]
}

export interface ChannelDto {
  id: string
  name: string
  avatarUrl: string
  bannerUrl: string
  description: string
  subscriberCount: number
  verified: boolean
  videos: VideoListItem[]
  nextpage: string | null
}

export interface ApiResponse<T> {
  data: T
  meta?: { nextPage?: string; total?: number }
}

/** Strip fields not needed in list responses. */
export function toVideoListItem(raw: Record<string, unknown>): VideoListItem {
  return {
    type: 'video',
    title: String(raw.title ?? ''),
    videoId: String(raw.id ?? raw.videoId ?? ''),
    author: String(raw.author ?? ''),
    authorId: String(raw.authorId ?? raw.channel_id ?? ''),
    authorUrl: String(raw.authorUrl ?? ''),
    videoThumbnails: Array.isArray(raw.videoThumbnails) ? raw.videoThumbnails as VideoThumbnail[] : [{ quality: 'medium', url: String(raw.thumbnail_url ?? ''), width: 320, height: 180 }],
    viewCount: Number(raw.viewCount ?? raw.view_count ?? 0),
    published: Number(raw.published ?? 0),
    publishedText: String(raw.publishedText ?? raw.published_at ?? ''),
    lengthSeconds: Number(raw.lengthSeconds ?? raw.duration_sec ?? 0),
    authorThumbnails: raw.authorThumbnails as VideoThumbnail[] | undefined,
    authorVerified: Boolean(raw.authorVerified ?? raw.verified),
    liveNow: Boolean(raw.liveNow),
  }
}

/** Build VideoDetail from DB row + raw_json (streams). */
export function toVideoDetailDto(row: Record<string, unknown>): VideoDetailDto {
  const raw = (row.raw_json as Record<string, unknown>) || {}
  const listItem = toVideoListItem({
    ...row,
    id: row.id,
    thumbnail_url: row.thumbnail_url,
    duration_sec: row.duration_sec,
    published_at: row.published_at,
    channel_id: row.channel_id,
  })
  const formatStreams = (raw.formatStreams as Array<{ url: string; quality: string; qualityLabel?: string }>) ?? []
  const adaptiveFormats = (raw.adaptiveFormats as Array<{ url: string; qualityLabel?: string; type: string; container: string }>) ?? []
  const recommendedVideos = ((raw.recommendedVideos as unknown[]) ?? []).map((v) => toVideoListItem(v as Record<string, unknown>))
  return {
    ...listItem,
    description: String(row.description ?? raw.description ?? ''),
    descriptionHtml: String(row.description ?? raw.description ?? ''),
    dashUrl: raw.dashUrl as string | undefined,
    hlsUrl: raw.hlsUrl as string | undefined,
    adaptiveFormats,
    formatStreams: formatStreams.map((s) => ({ url: s.url, quality: s.quality, qualityLabel: s.qualityLabel ?? s.quality })),
    recommendedVideos,
    likeCount: Number(raw.likeCount ?? raw.likes ?? 0),
    dislikeCount: Number(raw.dislikeCount ?? raw.dislikes ?? 0),
    subscriberCount: raw.subscriberCount as number | undefined,
    subtitles: (raw.subtitles as Array<{ url: string; mimeType?: string; name?: string; code?: string; autoGenerated?: boolean }>)?.map((s) => ({
      url: s.url,
      mimeType: s.mimeType ?? 'text/vtt',
      name: s.name ?? '',
      code: s.code ?? 'en',
      autoGenerated: s.autoGenerated ?? false,
    })),
  }
}
